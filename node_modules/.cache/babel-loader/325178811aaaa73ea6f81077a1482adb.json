{"ast":null,"code":"/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n'use strict'; // setImmediate\n\nif (!window.setImmediate) {\n  window.setImmediate = function setupSetImmediate() {\n    return window.msSetImmediate || window.webkitSetImmediate || window.mozSetImmediate || window.oSetImmediate || function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message'; // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' || evt.data.substr(0, message.length) !== message\n        /* ||\n        evt.source !== window */\n        ) {\n            return;\n          }\n\n        evt.stopImmediatePropagation();\n        var id = parseInt(evt.data.substr(message.length), 36);\n\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n      /* specify clearImmediate() here since we need the scope */\n\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    }() || // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  }();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = function setupClearImmediate() {\n    return window.msClearImmediate || window.webkitClearImmediate || window.mozClearImmediate || window.oClearImmediate || // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  }();\n}\n\n(function (global) {\n  // Check if WordCloud can run on this browser\n  var isSupported = function isSupported() {\n    var canvas = document.createElement('canvas');\n\n    if (!canvas || !canvas.getContext) {\n      return false;\n    }\n\n    var ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n      return false;\n    }\n\n    if (!ctx.getImageData) {\n      return false;\n    }\n\n    if (!ctx.fillText) {\n      return false;\n    }\n\n    if (!Array.prototype.some) {\n      return false;\n    }\n\n    if (!Array.prototype.push) {\n      return false;\n    }\n\n    return true;\n  }(); // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n\n\n  var minFontSize = function getMinFontSize() {\n    if (!isSupported) {\n      return;\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d'); // start from 20\n\n    var size = 20; // two sizes to measure\n\n    var hanWidth, mWidth;\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif';\n\n      if (ctx.measureText(\"\\uFF37\").width === hanWidth && ctx.measureText('m').width === mWidth) {\n        return size + 1;\n      }\n\n      hanWidth = ctx.measureText(\"\\uFF37\").width;\n      mWidth = ctx.measureText('m').width;\n      size--;\n    }\n\n    return 0;\n  }(); // Based on http://jsfromhell.com/array/shuffle\n\n\n  var shuffleArray = function shuffleArray(arr) {\n    for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) {}\n\n    return arr;\n  };\n\n  var WordCloud = function WordCloud(elements, options) {\n    if (!isSupported) {\n      return;\n    }\n\n    if (!Array.isArray(elements)) {\n      elements = [elements];\n    }\n\n    elements.forEach(function (el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el);\n\n        if (!elements[i]) {\n          throw 'The element id specified is not found.';\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw 'You must pass valid HTML elements, or ID of the element.';\n      }\n    });\n    /* Default values to be overwritten by options object */\n\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0,\n      // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff',\n      // opaque white = rgba(255, 255, 255, 1)\n      gridSize: 8,\n      drawOutOfBound: false,\n      origin: null,\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n      wait: 0,\n      abortThreshold: 0,\n      // disabled\n      abort: function noop() {},\n      minRotation: -Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationSteps: 0,\n      shuffle: true,\n      rotateRatio: 0.1,\n      shape: 'circle',\n      ellipticity: 0.65,\n      classes: null,\n      hover: null,\n      click: null\n    };\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key];\n        }\n      }\n    }\n    /* Convert weightFactor into a function */\n\n\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor;\n\n      settings.weightFactor = function weightFactor(pt) {\n        return pt * factor; //in px\n      };\n    }\n    /* Convert shape into a function */\n\n\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle';\n          break;\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid(theta) {\n            return 1 - Math.sin(theta);\n          };\n\n          break;\n\n        /*\n         To work out an X-gon, one has to calculate \"m\",\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n         Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n        where t' equals to mod(t, 2PI/X);\n         */\n\n        case 'diamond':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4);\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n          // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n          settings.shape = function shapeSquare(theta) {\n            return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));\n          };\n\n          break;\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'pentagon':\n          settings.shape = function shapePentagon(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n            return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'star':\n          settings.shape = function shapeStar(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n\n            if ((theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0) {\n              return 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime));\n            } else {\n              return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n            }\n          };\n\n          break;\n      }\n    }\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n\n\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n    /* shorthand */\n\n    var g = settings.gridSize;\n    var maskRectWidth = g - settings.maskGapWidth;\n    /* normalize rotation settings */\n\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n    var rotationSteps = Math.abs(Math.floor(settings.rotationSteps));\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n    /* information/object available to all functions, set when start() */\n\n    var grid, // 2d array containing filling information\n    ngx, ngy, // width and height of the grid\n    center, // position of the center of the cloud\n    maxRadius;\n    /* timestamp for measuring each putWord() action */\n\n    var escapeTime;\n    /* function for getting the color of the text */\n\n    var getTextColor;\n\n    function random_hsl_color(min, max) {\n      return 'hsl(' + (Math.random() * 360).toFixed() + ',' + (Math.random() * 30 + 70).toFixed() + '%,' + (Math.random() * (max - min) + min).toFixed() + '%)';\n    }\n\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor() {\n          return random_hsl_color(10, 50);\n        };\n\n        break;\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor() {\n          return random_hsl_color(50, 90);\n        };\n\n        break;\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color;\n        }\n\n        break;\n    }\n    /* function for getting the font-weight of the text */\n\n\n    var getTextFontWeight;\n\n    if (typeof settings.fontWeight === 'function') {\n      getTextFontWeight = settings.fontWeight;\n    }\n    /* function for getting the classes of the text */\n\n\n    var getTextClasses = null;\n\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes;\n    }\n    /* Interactive */\n\n\n    var interactive = false;\n    var infoGrid = [];\n    var hovered;\n\n    var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n      var canvas = evt.currentTarget;\n      var rect = canvas.getBoundingClientRect();\n      var clientX;\n      var clientY;\n      /** Detect if touches are available */\n\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX;\n        clientY = evt.touches[0].clientY;\n      } else {\n        clientX = evt.clientX;\n        clientY = evt.clientY;\n      }\n\n      var eventX = clientX - rect.left;\n      var eventY = clientY - rect.top;\n      var x = Math.floor(eventX * (canvas.width / rect.width || 1) / g);\n      var y = Math.floor(eventY * (canvas.height / rect.height || 1) / g);\n      return infoGrid[x][y];\n    };\n\n    var wordcloudhover = function wordcloudhover(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n\n      if (hovered === info) {\n        return;\n      }\n\n      hovered = info;\n\n      if (!info) {\n        settings.hover(undefined, undefined, evt);\n        return;\n      }\n\n      settings.hover(info.item, info.dimension, evt);\n    };\n\n    var wordcloudclick = function wordcloudclick(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n\n      if (!info) {\n        return;\n      }\n\n      settings.click(info.item, info.dimension, evt);\n      evt.preventDefault();\n    };\n    /* Get points on the grid for a given radius away from the center */\n\n\n    var pointsAtRadius = [];\n\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius];\n      } // Look for these number of points on each radius\n\n\n      var T = radius * 8; // Getting all the points at this radius\n\n      var t = T;\n      var points = [];\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0]);\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1;\n\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n        } // Push [x, y, t]; t is used solely for getTextColor()\n\n\n        points.push([center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * settings.ellipticity, t / T * 2 * Math.PI]);\n      }\n\n      pointsAtRadius[radius] = points;\n      return points;\n    };\n    /* Return true if we had spent too much time */\n\n\n    var exceedTime = function exceedTime() {\n      return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n    };\n    /* Get the deg of rotation according to settings, and luck. */\n\n\n    var getRotateDeg = function getRotateDeg() {\n      if (settings.rotateRatio === 0) {\n        return 0;\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0;\n      }\n\n      if (rotationRange === 0) {\n        return minRotation;\n      }\n\n      if (rotationSteps > 0) {\n        // Min rotation + zero or more steps * span of one step\n        return minRotation + Math.floor(Math.random() * rotationSteps) * rotationRange / (rotationSteps - 1);\n      } else {\n        return minRotation + Math.random() * rotationRange;\n      }\n    };\n\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false;\n      var fontSize = settings.weightFactor(weight);\n\n      if (fontSize <= settings.minSize) {\n        return false;\n      } // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n\n\n      var mu = 1;\n\n      if (fontSize < minFontSize) {\n        mu = function calculateScaleFactor() {\n          var mu = 2;\n\n          while (mu * fontSize < minFontSize) {\n            mu += 2;\n          }\n\n          return mu;\n        }();\n      } // Get fontWeight that will be used to set fctx.font\n\n\n      var fontWeight;\n\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize);\n      } else {\n        fontWeight = settings.fontWeight;\n      }\n\n      var fcanvas = document.createElement('canvas');\n      var fctx = fcanvas.getContext('2d', {\n        willReadFrequently: true\n      });\n      fctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Estimate the dimension of the text with measureText().\n\n      var fw = fctx.measureText(word).width / mu;\n      var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText(\"\\uFF37\").width) / mu; // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n\n      var boxWidth = fw + fh * 2;\n      var boxHeight = fh * 3;\n      var fgw = Math.ceil(boxWidth / g);\n      var fgh = Math.ceil(boxHeight / g);\n      boxWidth = fgw * g;\n      boxHeight = fgh * g; // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n      // This is simply half of the width.\n\n      var fillTextOffsetX = -fw / 2; // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n\n      var fillTextOffsetY = -fh * 0.4; // Calculate the actual dimension of the canvas, considering the rotation.\n\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n      var width = cgw * g;\n      var height = cgh * g;\n      fcanvas.setAttribute('width', width);\n      fcanvas.setAttribute('height', height);\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas); // Save it's state so that we could restore and draw the grid correctly.\n\n        fctx.save();\n      } // Scale the canvas with |mu|.\n\n\n      fctx.scale(1 / mu, 1 / mu);\n      fctx.translate(width * mu / 2, height * mu / 2);\n      fctx.rotate(-rotateDeg); // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n\n      fctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n\n      fctx.fillStyle = '#000';\n      fctx.textBaseline = 'middle';\n      fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu); // Get the pixels of the text\n\n      var imageData = fctx.getImageData(0, 0, width, height).data;\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n        fctx.restore();\n      } // Read the pixels and save the information to the occupied array\n\n\n      var occupied = [];\n      var gx = cgw,\n          gy,\n          x,\n          y;\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n\n      while (gx--) {\n        gy = cgh;\n\n        while (gy--) {\n          y = g;\n\n          singleGridLoop: {\n            while (y--) {\n              x = g;\n\n              while (x--) {\n                if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n                  occupied.push([gx, gy]);\n\n                  if (gx < bounds[3]) {\n                    bounds[3] = gx;\n                  }\n\n                  if (gx > bounds[1]) {\n                    bounds[1] = gx;\n                  }\n\n                  if (gy < bounds[0]) {\n                    bounds[0] = gy;\n                  }\n\n                  if (gy > bounds[2]) {\n                    bounds[2] = gy;\n                  }\n\n                  if (debug) {\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                  }\n\n                  break singleGridLoop;\n                }\n              }\n            }\n\n            if (debug) {\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n            }\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n        fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n      } // Return information needed to create the text on the real canvas\n\n\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      };\n    };\n    /* Determine if there is room available in the given dimension */\n\n\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length;\n\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false;\n          }\n\n          continue;\n        }\n\n        if (!grid[px][py]) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n    /* Actually draw the text on the grid */\n\n\n    var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes) {\n      var fontSize = info.fontSize;\n      var color;\n\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta);\n      } else {\n        color = settings.color;\n      } // get fontWeight that will be used to set ctx.font and font style rule\n\n\n      var fontWeight;\n\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize);\n      } else {\n        fontWeight = settings.fontWeight;\n      }\n\n      var classes;\n\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize);\n      } else {\n        classes = settings.classes;\n      }\n\n      var dimension;\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          var mu = info.mu; // Save the current state before messing it\n\n          ctx.save();\n          ctx.scale(1 / mu, 1 / mu);\n          ctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n          ctx.fillStyle = color; // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n\n          ctx.translate((gx + info.gw / 2) * g * mu, (gy + info.gh / 2) * g * mu);\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(-rotateDeg);\n          } // Finally, fill the text.\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n\n\n          ctx.textBaseline = 'middle';\n          ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu); // The below box is always matches how <span>s are positioned\n\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight); */\n          // Restore the state.\n\n          ctx.restore();\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span');\n          var transformRule = '';\n          transformRule = 'rotate(' + -rotateDeg / Math.PI * 180 + 'deg) ';\n\n          if (info.mu !== 1) {\n            transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n          }\n\n          var styleRules = {\n            'position': 'absolute',\n            'display': 'block',\n            'font': fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n            'left': (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n            'top': (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n            'width': info.fillTextWidth + 'px',\n            'height': info.fillTextHeight + 'px',\n            'lineHeight': fontSize + 'px',\n            'whiteSpace': 'nowrap',\n            'transform': transformRule,\n            'webkitTransform': transformRule,\n            'msTransform': transformRule,\n            'transformOrigin': '50% 40%',\n            'webkitTransformOrigin': '50% 40%',\n            'msTransformOrigin': '50% 40%'\n          };\n\n          if (color) {\n            styleRules.color = color;\n          }\n\n          span.textContent = word;\n\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp];\n          }\n\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute]);\n            }\n          }\n\n          if (classes) {\n            span.className += classes;\n          }\n\n          el.appendChild(span);\n        }\n      });\n    };\n    /* Help function to updateGrid */\n\n\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return;\n      }\n\n      grid[x][y] = false;\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d');\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = {\n          item: item,\n          dimension: dimension\n        };\n      }\n    };\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n\n\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied;\n      var drawMask = settings.drawMask;\n      var ctx;\n\n      if (drawMask) {\n        ctx = elements[0].getContext('2d');\n        ctx.save();\n        ctx.fillStyle = settings.maskColor;\n      }\n\n      var dimension;\n\n      if (interactive) {\n        var bounds = info.bounds;\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        };\n      }\n\n      var i = occupied.length;\n\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue;\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item);\n      }\n\n      if (drawMask) {\n        ctx.restore();\n      }\n    };\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n\n\n    var putWord = function putWord(item) {\n      var word, weight, attributes;\n\n      if (Array.isArray(item)) {\n        word = item[0];\n        weight = item[1];\n      } else {\n        word = item.word;\n        weight = item.weight;\n        attributes = item.attributes;\n      }\n\n      var rotateDeg = getRotateDeg(); // get info needed to put the text onto the canvas\n\n      var info = getTextInfo(word, weight, rotateDeg); // not getting the info means we shouldn't be drawing this one.\n\n      if (!info) {\n        return false;\n      }\n\n      if (exceedTime()) {\n        return false;\n      } // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n\n\n      if (!settings.drawOutOfBound) {\n        var bounds = info.bounds;\n\n        if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n          return false;\n        }\n      } // Determine the position to put the text by\n      // start looking for the nearest points\n\n\n      var r = maxRadius + 1;\n\n      var tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2);\n        var gy = Math.floor(gxy[1] - info.gh / 2);\n        var gw = info.gw;\n        var gh = info.gh; // If we cannot fit the text at this position, return false\n        // and go to the next position.\n\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false;\n        } // Actually put the text on the canvas\n\n\n        drawText(gx, gy, info, word, weight, maxRadius - r, gxy[2], rotateDeg, attributes); // Mark the spaces on the grid as filled\n\n        updateGrid(gx, gy, gw, gh, info, item); // Return true so some() will stop and also return true.\n\n        return true;\n      };\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r);\n\n        if (settings.shuffle) {\n          points = [].concat(points);\n          shuffleArray(points);\n        } // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n        // If all the points returns false, array.some() returns false.\n\n\n        var drawn = points.some(tryToPutWordAtPoint);\n\n        if (drawn) {\n          // leave putWord() and return true\n          return true;\n        }\n      } // we tried all distances but text won't fit, return false\n\n\n      return false;\n    };\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n\n\n    var sendEvent = function sendEvent(type, cancelable, detail) {\n      if (cancelable) {\n        return !elements.some(function (el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          return !el.dispatchEvent(evt);\n        }, this);\n      } else {\n        elements.forEach(function (el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          el.dispatchEvent(evt);\n        }, this);\n      }\n    };\n    /* Start drawing on a canvas */\n\n\n    var start = function start() {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0];\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g);\n        ngy = Math.ceil(canvas.height / g);\n      } else {\n        var rect = canvas.getBoundingClientRect();\n        ngx = Math.ceil(rect.width / g);\n        ngy = Math.ceil(rect.height / g);\n      } // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n\n\n      if (!sendEvent('wordcloudstart', true)) {\n        return;\n      } // Determine the center of the word cloud\n\n\n      center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / 2]; // Maxium radius to look for space\n\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n\n      grid = [];\n      var gx, gy, i;\n\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function (el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d');\n            ctx.fillStyle = settings.backgroundColor;\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          } else {\n            el.textContent = '';\n            el.style.backgroundColor = settings.backgroundColor;\n            el.style.position = 'relative';\n          }\n        });\n        /* fill the grid with empty state */\n\n        gx = ngx;\n\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n\n          while (gy--) {\n            grid[gx][gy] = true;\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d');\n        bctx.fillStyle = settings.backgroundColor;\n        bctx.fillRect(0, 0, 1, 1);\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n\n        var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n        gx = ngx;\n        var x, y;\n\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n\n          while (gy--) {\n            y = g;\n\n            singleGridLoop: while (y--) {\n              x = g;\n\n              while (x--) {\n                i = 4;\n\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false;\n                    break singleGridLoop;\n                  }\n                }\n              }\n            }\n\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true;\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined;\n      } // fill the infoGrid with empty state if we need it\n\n\n      if (settings.hover || settings.click) {\n        interactive = true;\n        /* fill the grid with empty state */\n\n        gx = ngx + 1;\n\n        while (gx--) {\n          infoGrid[gx] = [];\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover);\n        }\n\n        var touchend = function touchend(e) {\n          e.preventDefault();\n        };\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick);\n          canvas.addEventListener('touchstart', wordcloudclick);\n          canvas.addEventListener('touchend', touchend);\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {\n          canvas.removeEventListener('wordcloudstart', stopInteraction);\n          canvas.removeEventListener('mousemove', wordcloudhover);\n          canvas.removeEventListener('click', wordcloudclick);\n          canvas.removeEventListener('touchstart', wordcloudclick);\n          canvas.removeEventListener('touchend', touchend);\n          hovered = undefined;\n        });\n      }\n\n      i = 0;\n      var loopingFunction, stoppingFunction;\n\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout;\n        stoppingFunction = window.clearTimeout;\n      } else {\n        loopingFunction = window.setImmediate;\n        stoppingFunction = window.clearImmediate;\n      }\n\n      var addEventListener = function addEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.addEventListener(type, listener);\n        }, this);\n      };\n\n      var removeEventListener = function removeEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.removeEventListener(type, listener);\n        }, this);\n      };\n\n      var anotherWordCloudStart = function anotherWordCloudStart() {\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        stoppingFunction(timer);\n      };\n\n      addEventListener('wordcloudstart', anotherWordCloudStart);\n      var timer = loopingFunction(function loop() {\n        if (i >= settings.list.length) {\n          stoppingFunction(timer);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n\n        escapeTime = new Date().getTime();\n        var drawn = putWord(settings.list[i]);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i],\n          drawn: drawn\n        });\n\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n\n        i++;\n        timer = loopingFunction(loop, settings.wait);\n      }, settings.wait);\n    }; // All set, start the drawing\n\n\n    start();\n  };\n\n  WordCloud.isSupported = isSupported;\n  WordCloud.minFontSize = minFontSize; // Expose the library as an AMD module\n\n  if (typeof define === 'function' && define.amd) {\n    global.WordCloud = WordCloud;\n    define('wordcloud', [], function () {\n      return WordCloud;\n    });\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = WordCloud;\n  } else {\n    global.WordCloud = WordCloud;\n  }\n})(this); //jshint ignore:line","map":null,"metadata":{},"sourceType":"script"}